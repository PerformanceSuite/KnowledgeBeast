# KnowledgeBeast v2.3.1 Completion Plan

**Target Release**: October 15, 2025 (6 days from now)
**Focus**: Complete remaining v2.3.0 improvements (4 features, ~17h work)
**Execution Strategy**: 2 autonomous agents in parallel using existing feature branches
**Goal**: Achieve A grade (92/100) with all 12 improvements shipped

---

## Executive Summary

v2.3.1 completes the remaining work from v2.3.0 by finishing two partially complete PRs:
- **Agent 1 (Production Hardening)**: 65% complete, 7h remaining
- **Agent 2 (Security & Observability)**: 65% complete, 10h remaining

**Current Status**:
- ✅ 8/12 improvements shipped in v2.3.0 (67%)
- 🟡 4/12 improvements partially complete (65% each)
- 📊 Grade: A- (90/100) → Target: A (92/100)

**Strategy**: Complete existing branches, merge, and ship immediately.

---

## 🎯 Remaining Work Breakdown

### Agent 1: Production Hardening Branch
**Branch**: `feature/production-hardening`
**Status**: 65% complete (core infrastructure done, needs debugging + 2 new features)
**Estimated Time**: 7 hours
**Current State**: 22/34 API tests passing (65%), isolation fixtures implemented

#### Work Items

##### 1. Fix Test Isolation Issues (2h) - HIGH PRIORITY
**Status**: Core fixtures implemented, 12 tests still flaky

**Required Work**:
- Debug remaining 12 test failures in `tests/api/test_project_endpoints.py`
- Issues likely:
  - Database connections not fully cleaned between tests
  - ChromaDB collection persistence across tests
  - Cached API keys bleeding between tests
  - Shared mock objects causing state leakage

**Files to Modify**:
- `tests/api/conftest.py` (already has isolation fixtures, needs enhancement)
- `tests/api/test_project_endpoints.py` (fix failing assertions)

**Success Criteria**:
- 34/34 API tests passing (100%)
- Each test runs independently (can run in any order)
- Zero state leakage between tests

**Test Command**:
```bash
pytest tests/api/test_project_endpoints.py -v --tb=short
pytest tests/api/test_project_endpoints.py -v --count=10  # Verify stability
```

---

##### 2. Implement Per-Project Rate Limiting (2h) - NEW FEATURE
**Status**: Designed but not implemented

**Design**: Composite key function `{api_key}:{project_id}` for rate limiting

**Implementation Plan**:

**Step 1**: Update rate limiter to support composite keys
```python
# knowledgebeast/api/middleware.py (or new file: rate_limiter.py)

from slowapi import Limiter
from slowapi.util import get_remote_address

def get_project_rate_limit_key(request: Request) -> str:
    """Generate composite rate limit key: {api_key}:{project_id}"""
    api_key = request.headers.get("X-API-Key", "anonymous")
    project_id = request.path_params.get("project_id", "global")
    return f"{api_key}:{project_id}"

# Initialize limiter with custom key function
limiter = Limiter(key_func=get_project_rate_limit_key)
```

**Step 2**: Apply rate limits to project endpoints
```python
# knowledgebeast/api/routes.py

@router_v2.post("/projects/{project_id}/query")
@limiter.limit("100/minute")  # Per API key + project_id
async def query_project(project_id: str, ...):
    pass

@router_v2.post("/projects/{project_id}/ingest")
@limiter.limit("50/minute")  # Per API key + project_id
async def ingest_project(project_id: str, ...):
    pass
```

**Step 3**: Add tests
```python
# tests/api/test_rate_limiting.py

def test_per_project_rate_limiting():
    """Test that rate limits are per-project, not global"""
    # User A can hit project 1 limit without affecting project 2
    for _ in range(100):
        response = client.post(f"/api/v2/projects/{project1_id}/query", ...)
        assert response.status_code == 200

    # 101st request to project 1 should fail
    response = client.post(f"/api/v2/projects/{project1_id}/query", ...)
    assert response.status_code == 429

    # But project 2 should still work (separate limit)
    response = client.post(f"/api/v2/projects/{project2_id}/query", ...)
    assert response.status_code == 200
```

**Files to Create/Modify**:
- `knowledgebeast/api/rate_limiter.py` (NEW)
- `knowledgebeast/api/routes.py` (add @limiter.limit decorators)
- `tests/api/test_rate_limiting.py` (NEW, 8 tests)

**Success Criteria**:
- Rate limits enforced per `{api_key}:{project_id}`
- 429 status code returned when limit exceeded
- Rate limit headers included in response
- 8/8 tests passing

---

##### 3. Implement Project Resource Quotas (3h) - NEW FEATURE
**Status**: Designed but not implemented

**Design**: Document quotas per project with enforcement and quota endpoint

**Implementation Plan**:

**Step 1**: Add quota tracking to ProjectManager
```python
# knowledgebeast/core/project_manager.py

class ProjectManager:
    def __init__(self):
        self.quotas = {
            "max_documents": 10_000,  # Per project
            "max_storage_mb": 1_000,  # Per project
            "max_queries_per_day": 100_000,
        }

    def check_quota(self, project_id: str, quota_type: str) -> bool:
        """Check if project is within quota limits"""
        project = self.get_project(project_id)
        current = project.get(f"usage_{quota_type}", 0)
        limit = self.quotas.get(f"max_{quota_type}", float('inf'))
        return current < limit

    def increment_quota_usage(self, project_id: str, quota_type: str, amount: int = 1):
        """Increment quota usage counter"""
        # Update project metadata
        # Store in ChromaDB metadata or separate quota DB
```

**Step 2**: Enforce quotas in API routes
```python
# knowledgebeast/api/routes.py

@router_v2.post("/projects/{project_id}/ingest")
async def ingest_project(project_id: str, ...):
    # Check document quota before ingestion
    if not project_manager.check_quota(project_id, "documents"):
        raise HTTPException(
            status_code=402,  # Payment Required
            detail="Document quota exceeded. Upgrade plan or delete documents."
        )

    # Ingest document
    result = await project_manager.ingest(project_id, content)

    # Increment usage
    project_manager.increment_quota_usage(project_id, "documents")

    return result
```

**Step 3**: Add quota endpoint
```python
# knowledgebeast/api/routes.py

@router_v2.get("/projects/{project_id}/quota")
async def get_project_quota(project_id: str):
    """Get current quota usage and limits"""
    quota = project_manager.get_quota_status(project_id)
    return {
        "project_id": project_id,
        "quotas": {
            "documents": {
                "used": quota["documents_used"],
                "limit": quota["documents_limit"],
                "percentage": quota["documents_used"] / quota["documents_limit"] * 100
            },
            "storage_mb": {
                "used": quota["storage_used_mb"],
                "limit": quota["storage_limit_mb"],
                "percentage": quota["storage_used_mb"] / quota["storage_limit_mb"] * 100
            },
            "queries_today": {
                "used": quota["queries_today"],
                "limit": quota["queries_limit_per_day"],
                "percentage": quota["queries_today"] / quota["queries_limit_per_day"] * 100
            }
        }
    }
```

**Step 4**: Add tests
```python
# tests/api/test_quotas.py

def test_document_quota_enforcement():
    """Test that document ingestion is blocked when quota exceeded"""
    # Set low quota for testing
    project_manager.quotas["max_documents"] = 5

    # Ingest 5 documents (should succeed)
    for i in range(5):
        response = client.post(f"/api/v2/projects/{project_id}/ingest", ...)
        assert response.status_code == 200

    # 6th document should fail with 402
    response = client.post(f"/api/v2/projects/{project_id}/ingest", ...)
    assert response.status_code == 402
    assert "quota exceeded" in response.json()["detail"].lower()

def test_quota_endpoint():
    """Test quota status endpoint"""
    response = client.get(f"/api/v2/projects/{project_id}/quota")
    assert response.status_code == 200
    data = response.json()
    assert "quotas" in data
    assert "documents" in data["quotas"]
    assert data["quotas"]["documents"]["limit"] == 10_000
```

**Files to Modify/Create**:
- `knowledgebeast/core/project_manager.py` (add quota tracking)
- `knowledgebeast/api/routes.py` (add quota endpoint + enforcement)
- `tests/api/test_quotas.py` (NEW, 10 tests)

**Success Criteria**:
- Quota enforcement on ingest/query endpoints
- 402 status code when quota exceeded
- Quota endpoint returns accurate usage
- 10/10 tests passing

---

### Agent 2: Security & Observability Branch
**Branch**: `feature/security-observability`
**Status**: 65% complete (core implementation done, needs route instrumentation + tests + docs)
**Estimated Time**: 10 hours
**Current State**: Core auth system + metrics defined, routes not instrumented

#### Work Items

##### 1. Complete Route Instrumentation (2h) - HIGH PRIORITY
**Status**: Metrics and auth core implemented, routes need updates

**Current State**:
- ✅ `knowledgebeast/core/project_auth.py` - API key management implemented
- ✅ `knowledgebeast/utils/metrics.py` - 9 project-scoped metrics defined
- ❌ Routes not instrumented with metrics or auth middleware

**Required Work**:

**Step 1**: Instrument all routes with project metrics
```python
# knowledgebeast/api/routes.py

from knowledgebeast.utils.metrics import (
    record_project_query,
    record_project_ingestion,
    record_project_cache_hit,
)

@router_v2.post("/projects/{project_id}/query")
async def query_project(project_id: str, query: QueryRequest):
    start_time = time.time()

    try:
        result = await project_manager.query(project_id, query.query)

        # Record metrics
        latency_ms = (time.time() - start_time) * 1000
        record_project_query(
            project_id=project_id,
            latency_ms=latency_ms,
            result_count=len(result),
            cache_hit=result.get("cached", False)
        )

        return result
    except Exception as e:
        record_project_error(project_id, "query", str(e))
        raise
```

**Step 2**: Add project auth middleware
```python
# knowledgebeast/api/app.py

from knowledgebeast.api.project_auth_middleware import ProjectAuthMiddleware

app.add_middleware(ProjectAuthMiddleware)

# knowledgebeast/api/project_auth_middleware.py (already exists)
# Just needs to be registered in app.py
```

**Files to Modify**:
- `knowledgebeast/api/routes.py` (add metric recording to all project endpoints)
- `knowledgebeast/api/app.py` (register ProjectAuthMiddleware)

**Success Criteria**:
- All project endpoints emit metrics
- Project auth middleware validates API keys
- Metrics visible at `/metrics` endpoint

---

##### 2. Add Distributed Tracing Context (3h) - NEW FEATURE
**Status**: Designed but not implemented

**Design**: Add `project_id` to all trace spans for better observability

**Implementation Plan**:

**Step 1**: Enhance OpenTelemetry spans with project context
```python
# knowledgebeast/utils/observability.py (already exists, needs enhancement)

from opentelemetry import trace
from opentelemetry.trace import Status, StatusCode

def add_project_context(span, project_id: str, project_name: str = None):
    """Add project context to current trace span"""
    span.set_attribute("project.id", project_id)
    if project_name:
        span.set_attribute("project.name", project_name)
    span.set_attribute("project.tenant", "default")  # For future multi-tenancy

def trace_project_operation(operation: str):
    """Decorator to trace project operations with context"""
    def decorator(func):
        @wraps(func)
        async def wrapper(project_id: str, *args, **kwargs):
            tracer = trace.get_tracer(__name__)
            with tracer.start_as_current_span(f"project.{operation}") as span:
                add_project_context(span, project_id)
                try:
                    result = await func(project_id, *args, **kwargs)
                    span.set_status(Status(StatusCode.OK))
                    return result
                except Exception as e:
                    span.set_status(Status(StatusCode.ERROR, str(e)))
                    span.record_exception(e)
                    raise
        return wrapper
    return decorator
```

**Step 2**: Apply tracing to all project operations
```python
# knowledgebeast/core/project_manager.py

from knowledgebeast.utils.observability import trace_project_operation

class ProjectManager:
    @trace_project_operation("query")
    async def query(self, project_id: str, query_text: str):
        """Query project with distributed tracing"""
        pass

    @trace_project_operation("ingest")
    async def ingest(self, project_id: str, content: str):
        """Ingest document with distributed tracing"""
        pass
```

**Step 3**: Add baggage propagation for cross-service context
```python
# knowledgebeast/api/routes.py

from opentelemetry.baggage import set_baggage, get_baggage

@router_v2.post("/projects/{project_id}/query")
async def query_project(project_id: str, ...):
    # Set baggage for downstream services
    set_baggage("project.id", project_id)
    set_baggage("project.operation", "query")

    result = await project_manager.query(project_id, ...)
    return result
```

**Files to Modify**:
- `knowledgebeast/utils/observability.py` (add project context helpers)
- `knowledgebeast/core/project_manager.py` (add tracing decorators)
- `knowledgebeast/api/routes.py` (add baggage propagation)
- `tests/observability/test_project_tracing.py` (NEW, 12 tests)

**Success Criteria**:
- All project operations traced with project_id
- Traces visible in Jaeger with project context
- Baggage propagated to downstream operations
- 12/12 tests passing

---

##### 3. Write Comprehensive Tests (2h) - HIGH PRIORITY
**Status**: Not started (blocking PR merge)

**Required Tests**:

**Test 1**: Project API Key Tests (`tests/api/test_project_api_keys.py`)
```python
def test_create_api_key():
    """Test creating project-specific API key"""
    response = client.post(f"/api/v2/projects/{project_id}/api-keys", json={
        "name": "production-key",
        "scopes": ["read", "write"],
        "expires_in_days": 90
    })
    assert response.status_code == 201
    data = response.json()
    assert "key" in data
    assert "key_id" in data
    assert data["scopes"] == ["read", "write"]

def test_api_key_scope_enforcement():
    """Test that API keys respect scope restrictions"""
    # Create read-only key
    key = create_api_key(project_id, scopes=["read"])

    # Query should work (read scope)
    response = client.post(f"/api/v2/projects/{project_id}/query",
                           headers={"X-API-Key": key})
    assert response.status_code == 200

    # Ingest should fail (no write scope)
    response = client.post(f"/api/v2/projects/{project_id}/ingest",
                           headers={"X-API-Key": key})
    assert response.status_code == 403

def test_api_key_expiration():
    """Test that expired keys are rejected"""
    # Create key that expires immediately
    key = create_api_key(project_id, expires_in_days=0)
    time.sleep(1)  # Wait for expiration

    response = client.post(f"/api/v2/projects/{project_id}/query",
                           headers={"X-API-Key": key})
    assert response.status_code == 401
    assert "expired" in response.json()["detail"].lower()
```

**Test 2**: Project Metrics Tests (`tests/observability/test_project_metrics.py`)
```python
def test_project_query_metrics():
    """Test that query metrics are recorded per project"""
    # Make query
    response = client.post(f"/api/v2/projects/{project_id}/query", ...)
    assert response.status_code == 200

    # Check metrics endpoint
    metrics = requests.get("http://localhost:8000/metrics").text
    assert f'project_queries_total{{project_id="{project_id}"}}' in metrics
    assert f'project_query_latency_seconds{{project_id="{project_id}"}}' in metrics

def test_project_metrics_isolation():
    """Test that metrics are isolated per project"""
    # Make queries to two different projects
    client.post(f"/api/v2/projects/{project1_id}/query", ...)
    client.post(f"/api/v2/projects/{project2_id}/query", ...)

    # Check that metrics are separate
    metrics = requests.get("http://localhost:8000/metrics").text
    assert f'project_queries_total{{project_id="{project1_id}"}} 1' in metrics
    assert f'project_queries_total{{project_id="{project2_id}"}} 1' in metrics
```

**Test 3**: Distributed Tracing Tests (`tests/observability/test_project_tracing.py`)
```python
def test_project_context_in_traces():
    """Test that project_id is included in all trace spans"""
    # Make query (generates trace)
    response = client.post(f"/api/v2/projects/{project_id}/query", ...)

    # Check Jaeger for trace (requires test Jaeger instance)
    traces = get_jaeger_traces(service_name="knowledgebeast")
    assert len(traces) > 0

    span = traces[0].spans[0]
    assert span.tags["project.id"] == project_id
    assert span.operation_name == "project.query"
```

**Files to Create**:
- `tests/api/test_project_api_keys.py` (15 tests)
- `tests/observability/test_project_metrics.py` (12 tests)
- `tests/observability/test_project_tracing.py` (12 tests)

**Success Criteria**:
- 39 new tests passing (100%)
- API key system fully validated
- Metrics verified per-project
- Tracing context validated

---

##### 4. Create Multi-Project API Documentation (4h) - DOCUMENTATION
**Status**: Not started (template ready)

**Scope**: Comprehensive API documentation for multi-project features

**Document Structure**:

```markdown
# Multi-Project API Guide

## Overview
- Multi-project architecture
- Use cases (multiple clients, environments, isolated datasets)
- Key concepts (projects, API keys, quotas, isolation)

## Getting Started
- Create your first project
- Generate API keys
- Ingest documents
- Query your project

## Project Management
- Create project (POST /api/v2/projects)
- List projects (GET /api/v2/projects)
- Get project details (GET /api/v2/projects/{id})
- Update project (PUT /api/v2/projects/{id})
- Delete project (DELETE /api/v2/projects/{id})

## Document Management
- Ingest documents (POST /api/v2/projects/{id}/ingest)
- List documents (GET /api/v2/projects/{id}/documents)
- Delete document (DELETE /api/v2/projects/{id}/documents/{doc_id})

## Querying
- Query project (POST /api/v2/projects/{id}/query)
- Streaming queries (POST /api/v2/projects/{id}/query/stream)
- Query parameters (search_type, limit, filters)

## Authentication
- Global API keys vs project API keys
- Creating project-specific API keys
- Scope-based permissions (read, write, admin)
- API key rotation and expiration

## Monitoring
- Project health (GET /api/v2/projects/{id}/health)
- Project statistics (GET /api/v2/projects/{id}/stats)
- Quota usage (GET /api/v2/projects/{id}/quota)

## Rate Limiting
- Per-project rate limits
- Rate limit headers
- Handling 429 responses

## Best Practices
- Project naming conventions
- API key management
- Quota monitoring
- Performance optimization

## Examples
- Python client examples
- cURL examples
- JavaScript/TypeScript examples

## Troubleshooting
- Common errors and solutions
- Debugging tips
- Support resources
```

**Files to Create**:
- `docs/api/MULTI_PROJECT_GUIDE.md` (comprehensive guide, ~1500 lines)
- `examples/multi_project_client.py` (Python client examples)
- `examples/multi_project_curl.sh` (cURL examples)

**Success Criteria**:
- Complete API reference for all project endpoints
- Working code examples in 2+ languages
- Troubleshooting section with common issues
- Ready for user adoption

---

## 📊 Execution Strategy

### Parallel Execution with Git Worktrees

**Agent 1**: Production Hardening (7 hours)
```bash
cd /Users/danielconnolly/Projects/KnowledgeBeast
git worktree add ../KnowledgeBeast-agent1 feature/production-hardening
```

**Agent 2**: Security & Observability (10 hours)
```bash
cd /Users/danielconnolly/Projects/KnowledgeBeast
git worktree add ../KnowledgeBeast-agent2 feature/security-observability
```

### Agent Dependencies

**No blocking dependencies** - Both agents work on separate codebases:
- Agent 1: API routes, rate limiting, quotas
- Agent 2: Auth middleware, metrics, tracing, docs

**Potential merge conflicts**:
- `knowledgebeast/api/routes.py` - Both agents modify
- Resolution: Agent 2 merges first (less complex), Agent 1 rebases

---

## 🎯 Success Criteria

### Test Coverage
| Component | Current | Target | New Tests |
|-----------|---------|--------|-----------|
| Agent 1 (Production) | 22/34 (65%) | 52/52 (100%) | +18 tests |
| Agent 2 (Security) | 0/39 (0%) | 39/39 (100%) | +39 tests |
| **Total** | **22/73** | **91/91** | **+57 tests** |

### Code Quality
- [ ] All tests passing (100%)
- [ ] Zero merge conflicts (or cleanly resolved)
- [ ] Code review approval (self-review checklist)
- [ ] Documentation complete

### Performance
- [ ] No performance regressions
- [ ] Rate limiting < 5ms overhead
- [ ] Quota checks < 2ms overhead
- [ ] Metrics recording < 1ms overhead

### User Experience
- [ ] Clear API documentation
- [ ] Working code examples
- [ ] Error messages are actionable
- [ ] Migration guide provided

---

## 📅 Timeline

**Day 1-2 (Oct 9-10)**: Agent 1 & 2 work in parallel
- Agent 1: Fix test isolation (2h), implement rate limiting (2h), start quotas (3h)
- Agent 2: Instrument routes (2h), add tracing (3h), start tests (2h)

**Day 3 (Oct 11)**: Complete implementation
- Agent 1: Finish quotas, test everything
- Agent 2: Finish tests, start documentation

**Day 4 (Oct 12)**: Testing & Documentation
- Agent 1: Integration testing, PR ready
- Agent 2: Complete documentation, PR ready

**Day 5 (Oct 13)**: Merge & Release
- Merge Agent 2 first (simpler conflicts)
- Rebase Agent 1, resolve conflicts, merge
- Tag v2.3.1, push to GitHub

**Day 6 (Oct 14)**: Validation
- Run full test suite
- Performance benchmarking
- Documentation review

**Day 7 (Oct 15)**: Release
- Publish v2.3.1 release notes
- Update documentation
- Announce release

---

## 🚀 Launch Commands

### Manual Launch (Sequential)

```bash
# Agent 1: Production Hardening
cd /Users/danielconnolly/Projects/KnowledgeBeast
git worktree add ../KnowledgeBeast-agent1 feature/production-hardening
cd ../KnowledgeBeast-agent1

# Agent 2: Security & Observability
cd /Users/danielconnolly/Projects/KnowledgeBeast
git worktree add ../KnowledgeBeast-agent2 feature/security-observability
cd ../KnowledgeBeast-agent2
```

### Autonomous Launch (Parallel)

Will create `launch_v2.3.1_agents.sh` script for one-command execution.

---

## 📈 Expected Outcomes

### Quality Improvement
- **Before v2.3.1**: A- (90/100)
- **After v2.3.1**: A (92/100)
- **Improvement**: +2 points

### Feature Completeness
- **Before**: 8/12 improvements (67%)
- **After**: 12/12 improvements (100%)
- **Improvement**: +33%

### Test Coverage
- **Before**: 1,413 tests (78.4% pass rate)
- **After**: 1,470+ tests (85%+ pass rate)
- **Improvement**: +57 tests, +6.6% pass rate

### Production Readiness
- ✅ Per-project rate limiting
- ✅ Resource quota enforcement
- ✅ Project-scoped API keys
- ✅ Full observability (metrics + tracing)
- ✅ Complete API documentation
- ✅ Zero test isolation issues

---

## 📝 Commit Strategy

### Agent 1 Commits
```bash
git commit -m "fix: Resolve 12 remaining test isolation issues"
git commit -m "feat: Add per-project rate limiting with composite keys"
git commit -m "feat: Implement project resource quotas (documents, storage, queries)"
git commit -m "test: Add 18 tests for rate limiting and quotas"
```

### Agent 2 Commits
```bash
git commit -m "feat: Instrument all routes with project metrics"
git commit -m "feat: Add distributed tracing context for all project operations"
git commit -m "test: Add 39 comprehensive tests for auth, metrics, and tracing"
git commit -m "docs: Create multi-project API guide with examples"
```

---

## 🔍 Quality Checklist

### Before PR Creation
- [ ] All tests passing locally
- [ ] Code formatted with black/ruff
- [ ] Type hints complete (mypy passing)
- [ ] Docstrings added for all public methods
- [ ] Examples tested and working
- [ ] No debug print statements
- [ ] No commented-out code
- [ ] Git history clean (squash if needed)

### PR Description Template
```markdown
## Summary
[Agent 1 or Agent 2 completion summary]

## Changes
- Fix: [List bug fixes]
- Feat: [List new features]
- Test: [List test additions]
- Docs: [List documentation updates]

## Test Results
- Tests passing: X/X (100%)
- Code coverage: X%
- Performance: No regressions

## Breaking Changes
None - fully backward compatible

## Checklist
- [x] Tests added and passing
- [x] Documentation updated
- [x] No performance regressions
- [x] Ready for merge
```

---

## 🎯 Post-Merge Actions

### After Both PRs Merged

1. **Tag v2.3.1 Release**
```bash
git tag -a v2.3.1 -m "KnowledgeBeast v2.3.1 - Complete v2.3.0 Improvements"
git push origin v2.3.1
```

2. **Create Release Notes**
- Document all 12 improvements (8 from v2.3.0 + 4 from v2.3.1)
- Include performance metrics
- Add migration guide
- Highlight breaking changes (none expected)

3. **Update Documentation**
- Update README.md with v2.3.1 features
- Add multi-project guide to docs
- Update API reference

4. **Announce Release**
- GitHub release with full notes
- Update project status to "Production Ready"
- Share with community

---

## 📞 Support & Resources

### Development Resources
- Project Memory: `.claude/memory.md`
- v2.3.0 Roadmap: `.claude/v2.3.0_roadmap.md`
- v2.3.0 Implementation: `.claude/v2.3.0_improvements_plan.md`

### Testing Resources
- Test Runner: `pytest tests/ -v --tb=short`
- Coverage: `pytest tests/ --cov=knowledgebeast --cov-report=html`
- Performance: `pytest tests/performance/ -v`

### Git Resources
- Main Branch: `main`
- Agent 1 Branch: `feature/production-hardening`
- Agent 2 Branch: `feature/security-observability`

---

**Last Updated**: October 9, 2025
**Status**: Ready to Execute
**Target Completion**: October 15, 2025
**Expected Grade**: A (92/100)
**Confidence**: High (both branches 65% complete)
